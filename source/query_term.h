/*
	QUERY_TERM.H
	------------
	Copyright (c) 2017 Andrew Trotman
	Released under the 2-clause BSD license (See:https://en.wikipedia.org/wiki/BSD_licenses)
*/
/*!
	@file
	@brief Details of a term from a query
	@author Andrew Trotman
	@copyright 2017 Andrew Trotman
*/
#pragma once

#include "unicode.h"
#include "allocator.h"
#include "dynamic_array.h"

namespace JASS
	{
	/*
		CLASS QUERY_TERM
		----------------
	*/
	/*!
		@brief Details of a query term as parsed from the query.
		@details Objects of this type are generated by the query parsers and used to pass around details
		of a term used in a query
	*/
	class query_term
		{
		friend std::ostream &operator<<(std::ostream &stream, const query_term &term);

		private:
			slice term;						///< The term.  Note that the memory is kept elsewhere
			size_t query_frequency;		///< Number of times the term occurs in the query

		public:
			/*
				QUERY_TERM
				----------
			*/
			/*!
				@brief Constructor for an empty object.
			*/
			query_term() :
				query_frequency(0)
				{
				/* Nothing */
				}

			/*
				QUERY_TERM
				----------
			*/
			/*!
				@brief Copy constructor.
				@param original [in] object to copy (note:n This is a shallow copy).
			*/
			query_term(const query_term &original) :
				term(original.term),
				query_frequency(original.query_frequency)
				{
				/* Nothing */
				}

			/*
				QUERY_TERM
				----------
			*/
			/*!
				@brief Constructor.
				@param term [in] Term that this object reprrsents.
				@param query_frequency [in] the number of times the term occurs in the query.
				
				@details Create a new query term object from a string and a frequency.  Node that the term slice is copied and that
				the term is nod duplicated.  That is, the memory containing the query term belongs to the caller and not to this object.
				This isn't a problem because ll memory associated with processing a query should be in a single allocator object.
			*/
			query_term(const slice &term, size_t query_frequency = 1) :
				term(term),
				query_frequency(query_frequency)
				{
				/* Nothing */
				}
		};


	/*
		TYPEDEF TOKEN_LIST
		------------------
	*/
	/*!
		@typedef 
		@brief A list of tokens (i.e. a query).
	*/
	typedef dynamic_array<query_term> token_list;

	/*
		OPERATOR<<()
		------------
	*/
	/*!
		@brief Dump the contents of a query_term down an output stream.
		@param stream [in] The stream to write to.
		@param term [in] The query_term to write.
		@return The stream once the slice has been written.
	*/
	inline std::ostream &operator<<(std::ostream &stream, const query_term &term)
		{
		stream << "(" << term.term << "," << term.query_frequency << ")";
		return stream;
		}

	}
